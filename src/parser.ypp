%skeleton "lalr1.cc"
%require "3.0.4"
%defines
%define parser_class_name {lisplike_parser}

%define api.token.constructor
%define api.value.type variant
%define parse.assert

%code requires
{
#include <string>
class lisplike_driver;
}

// Params that are passed to the parser and lexer
%param { lisplike_driver& driver }

%locations
%initial-action
{
  // Initialize the initial location
  @$.begin.filename = @$.end.filename = &driver.streamname;
}

%define parse.trace
%define parse.error verbose

%code
{
#include "driver.hpp"
#include "scanner.hpp"
#undef yylex
#define yylex driver.lexer->lex
}


%define api.token.prefix {TOK_}
%token
  END   0 "end of file"
  LPAREN "("
  RPAREN ")"
;
%token <std::string> IDENTIFIER "identifier"
%token <int> NUMBER "number"
%type <int> exp


%printer { yyoutput << $$; } <*>;

%%

%start exp_list
  ;

exp_list
  : exp exp_list  { }
  | %empty        { }
  ;

exp
  : LPAREN "identifier" term_list RPAREN exp {  }
  ;

term_list 
  : term term_list { }
  | %empty
  ;

term
  : "identifier" { }
  | "number" { }
  | exp      { }
  ;

%%

void yy::lisplike_parser::error(const location_type& l, const std::string& m)
{
  driver.error(l, m);
}