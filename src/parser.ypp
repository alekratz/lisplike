%skeleton "lalr1.cc"
%require "3.0.4"
%defines
%define parser_class_name {lisplike_parser}

%define api.token.constructor
%define api.value.type variant
%define parse.assert

%code requires
{
#include <memory>
#include <vector>
#include <string>
#include "ll_type.hpp"
class lisplike_driver;
}

// Params that are passed to the parser and lexer
%param { lisplike_driver& driver }

%locations
%initial-action
{
  // Initialize the initial location
  @$.begin.filename = @$.end.filename = &driver.streamname;
}

%define parse.trace
%define parse.error verbose

%code
{
#include "driver.hpp"
#include "scanner.hpp"
#include "ll_type.hpp"
#undef yylex
#define yylex driver.lexer->lex
}


%define api.token.prefix {TOK_}
%token
  END   0 "end of file"
  LPAREN "("
  RPAREN ")"
  SQUOT "'"
  FUN_KEYW  "fun"
  LET_KEYW  "let"
;
%token <std::string> IDENTIFIER "identifier"
%token <double> NUMBER "number"
%token <std::string> STRING "string"

%type <ll_line_vec> unit
%type <ll_line_p> exp
%type <ll_line_p> funcall_exp
%type <ll_line_p> fundecl_exp
/* TODO: add a "function" type to the lisplike_value */
/* %type <lisplike_value> fundecl_exp */
%type <ll_line_p> let_exp
%type <ll_line_p> term
%type <ll_line_p> list
%type <ll_line_vec> term_list

%printer { yyoutput << $$; } <*>;

%%

%start unit;

unit
  : exp unit { 
    $2.push_back($1);
    $$ = $2;
  }
  | %empty { $$ = ll_line_vec(); }
  ;

exp
  : funcall_exp { $$ = $1; }
  | fundecl_exp { $$ = $1; }
  | let_exp     { $$ = $1; }
  ;

funcall_exp
  : LPAREN IDENTIFIER term_list RPAREN {
    $$ = std::make_shared<ll_funcall>(ll_funcall($2, $3));
    std::cout << $$ << std::endl;
  }
  ;

fundecl_exp
  : LPAREN FUN_KEYW IDENTIFIER list term_list RPAREN {
    $$ = std::make_shared<ll_fundecl>(ll_fundecl($3, $4, $5)); 
    std::cout << $$ << std::endl;
  }
  ;

let_exp
  : LPAREN LET_KEYW IDENTIFIER term RPAREN {
    $$ = std::make_shared<ll_let>(ll_let($3, $4));
    std::cout << $$ << std::endl; // output for testing reasons
  }
  ;

term_list 
  : term term_list { 
    $2.push_back($1);
    $$ = $2;
  }
  | %empty { $$ = ll_line_vec(); }
  ;

term
  : exp         { $$ = $1; }
  | list        { $$ = $1; }
  | IDENTIFIER  {
    /* TODO: resolve this to a value */ 
    $$ = std::make_shared<ll_value, cstref>($1); 
  }
  | NUMBER      { $$ = std::make_shared<ll_value>(ll_value($1)); }
  | STRING      { $$ = std::make_shared<ll_value, cstref>($1); }
  ;

list
  : SQUOT LPAREN term_list RPAREN { $$ = std::make_shared<ll_value>($3); }
  ;

%%

void yy::lisplike_parser::error(const location_type& l, const std::string& m)
{
  driver.error(l, m);
}
