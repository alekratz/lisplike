%skeleton "lalr1.cc"
%require "3.0.4"
%defines
%define parser_class_name {lisplike_parser}

%define api.token.constructor
%define api.value.type variant
%define parse.assert

%code requires
{
#include <memory>
#include <vector>
#include <string>
#include "ast.hpp"
class lisplike_driver;
}

// Params that are passed to the parser and lexer
%param { lisplike_driver& driver }

%locations
%initial-action
{
    // Initialize the initial location
    @$.begin.filename = @$.end.filename = &driver.streamname;
}

%define parse.trace
%define parse.error verbose

%code
{
#include "driver.hpp"
#include "scanner.hpp"
#undef yylex
#define yylex driver.lexer->lex
}


%define api.token.prefix {TOK_}
%token
    END     0 "end of file"
    LPAREN "("
    RPAREN ")"
    SQUOT "'"
    FUN_KEYW    "fun"
    LET_KEYW    "let"
    IF_KEYW     "if"
;
%token <std::string> IDENTIFIER "identifier"
%token <long double> NUMBER     "number"
%token <std::string> STRING     "string"
%token <std::string> COND_SYM   "cond_sym"
%token <std::string> MATH_OP    "math_op"

%type <ll_children> unit
%type <ll_tree_p> exp
%type <ll_tree_p> funcall_exp
%type <ll_tree_p> fundecl_exp
%type <ll_tree_p> let_exp
%type <ll_tree_p> if_exp
%type <ll_tree_p> bool_exp
%type <ll_tree_p> math_exp
%type <ll_children> term_list
%type <ll_tree_p> term
%type <ll_tree_p> list

%printer { yyoutput << $$; } <*>;

%%

%start unit;

unit
    : exp unit { 
        $2.insert($2.begin(), $1);
        $$ = $2;
        driver.ast = $$;
    }
    | %empty { $$ = ll_children(); }
    ;

exp
    : funcall_exp   { $$ = $1; }
    | fundecl_exp   { $$ = $1; }
    | let_exp       { $$ = $1; }
    | if_exp        { $$ = $1; }
    | bool_exp      { $$ = $1; }
    | math_exp      { $$ = $1; }
    ;

funcall_exp
    : LPAREN IDENTIFIER term_list RPAREN {
        $$ = std::make_shared<ll_funcall_exp>(ll_funcall_exp($2, $3));
    }
    ;

fundecl_exp
    : LPAREN FUN_KEYW IDENTIFIER list term_list RPAREN {
        $$ = std::make_shared<ll_fundecl_exp>(ll_fundecl_exp($3, ll_term_cast($4), $5));
    }
    ;

let_exp
    : LPAREN LET_KEYW IDENTIFIER term RPAREN { 
        $$ = std::make_shared<ll_let_exp>(ll_let_exp($3, ll_term_cast($4))); 
    }
    ;

if_exp
    : LPAREN IF_KEYW bool_exp term term RPAREN {
        $$ = std::make_shared<ll_if_exp>(ll_if_exp($3, $4, $5));
    }
    ;

bool_exp
    : LPAREN COND_SYM term term RPAREN {
        $$ = std::make_shared<ll_bool_exp>(ll_bool_exp($2, $3, $4));
    }
    ;

math_exp
    : LPAREN MATH_OP term_list RPAREN {
        if($3.size() < 2)
            driver.error(driver.lexer->loc, "math expression requires at least two arguments");
        $$ = std::make_shared<ll_math_exp>(ll_math_exp($2, $3));
    }

term_list 
    : term term_list { 
        $2.insert($2.begin(), $1);
        $$ = $2;
    }
    | %empty { $$ = ll_children(); }
    ;

term
    : exp           { $$ = $1; }
    | list          { $$ = $1; }
    | IDENTIFIER    {
        /* TODO: resolve this to a value */
        $$ = std::make_shared<ll_term, cstref>($1);
    }
    | NUMBER        { $$ = std::make_shared<ll_term>(ll_term($1)); }
    | STRING        { $$ = std::make_shared<ll_term, cstref>($1); }
    ;

list
    : SQUOT LPAREN term_list RPAREN { $$ = std::make_shared<ll_term>($3); }
    ;

%%

void yy::lisplike_parser::error(const location_type& l, const std::string& m)
{
    driver.error(l, m);
}
